(ns active.data.raw-record-test
  (:require [active.data.raw-record :as sut #?@(:cljs [:include-macros true])]
            [active.data.struct :as struct]
            [active.data.struct.validator :as validator]
            #?(:clj [clojure.pprint :as pp]
               :cljs [cljs.pprint :as pp])
            #?(:clj [clojure.test :as t]
               :cljs [cljs.test :as t :include-macros true])))

;; Focuses on what is different than in structs

#?(:clj
   (t/deftest parse-def-record-args-test
     (t/is (= '{:fields [{:name arg1} {:name arg2}]}
              (sut/parse-def-record-args '([arg1 arg2]))))
     (t/is (= '{:fields []}
              (sut/parse-def-record-args '([]))))
  
     (t/is (= '{:options [{:name :validator, :value x}], :fields []}
              (sut/parse-def-record-args '(:validator x []))))
     (t/is (= '{:options [{:name :extends, :value x}], :fields []}
              (sut/parse-def-record-args '(:extends x []))))
     (t/is (= '{:docstring "docstring", :options [{:name :extends, :value x}], :fields [{:name arg1 :docstring "a doc"}]}
              (sut/parse-def-record-args '("docstring" :extends x [arg1 "a doc"]))))

     #_(t/is (= :clojure.spec.alpha/invalid
                (sut/parse-def-record-args '(:other x []))))))

(defn throws [t]
  #?(:clj (try (t) nil (catch Throwable e e))
     :cljs (try (t) nil (catch :default e e))))

(sut/def-record R "a docstring"
  [r-a "field a"
   r-b])

(sut/def-record OtherR
  [or-a or-b])

(sut/def-record ^:private PrivT [pt-a ^{:private false} pt-b])

(t/deftest meta-data-test
  (t/testing "docstring"
    (t/is (= "field a" (:doc (meta #'r-a))))

    (t/is (= "a docstring" (:doc (meta #'R)))))
  
  (t/testing "private inheritance"
   (t/is (:private (meta #'PrivT)))
   (t/is (:private (meta #'pt-a)) "Privateness is inherited")
   (t/is (not (:private (meta #'pt-b))) "Privateness is inherited only as a default")))

(t/deftest construction-test
  (t/is (some? (R r-a 42 r-b "foo")))

  (t/is (some? (throws #(R :bar 42)))
        "Cannot construct with foreign fields")

  (t/is (= (R r-a 42 r-b "foo") ((sut/constructor R) 42 "foo")))

  (t/testing "predicates"
    (let [v (R r-a 42 r-b "foo")]
      (t/is (sut/is-a? R v))
      (t/is (sut/is-exactly-a? R v)))))

(t/deftest equality-test
  (t/is (= R R))
  
  ;; instances are equal
  (t/is (= (R r-a 42 r-b "foo") (R r-a 42 r-b "foo")))

  (t/is (= (R r-a 10 r-b "foo") (r-a (R r-a 42 r-b "foo") 10)))

  ;; not equal to maps
  (t/is (not= (R r-a 42 r-b "foo") {r-a 42 r-b "foo"})))

#?(:clj
   (t/deftest non-generative-clj-test
     (let [[t1 v1 get-1] (eval '(vector (active.data.raw-record/def-record A [a])
                                        (A a :foo)
                                        a))
           [t2 v2 get-2] (eval '(vector (active.data.raw-record/def-record A [a])
                                        (A a :foo)
                                        a))]
       
       ;; records and instances are equal
       (t/is (= t1 t2))
       
       (t/is (= v1 v2))

       ;; both values are exact instances of the "other" record
       (t/is (sut/is-exactly-a? t1 v2))
       (t/is (sut/is-exactly-a? t2 v1))

       ;; access works too either way
       (t/is (= :foo (get-1 v2)))
       (t/is (= :foo (get-2 v1)))
       )))

(t/deftest reflection-test
  (t/is (= R (sut/record-of (R r-a 42 r-b :foo))))

  (t/is (=  [r-a r-b] (sut/record-keys R)))

  (t/is (= 'active.data.raw-record-test/R (sut/record-name R))))

(t/deftest keys-test
  (let [v (R r-a 42 r-b "foo")]
    (t/is (= 42 (r-a v)))
    (t/is (= "foo" (r-b v)))

    (t/is (= 11 (r-a (r-a v 11))))
    (t/is (= "bla" (r-b (r-b v "bla"))))

    (t/is (throws #(r-a {})) "optimized accessor checks type")
    (t/is (throws #(or-a (R r-a 42 r-b "foo"))))
    (t/is (throws #(r-a {} 42)) "optimized mutator checks type")
    (t/is (throws #((sut/mutator! R r-a) (transient {}) 42)) "optimized mutator! checks type")

    (t/testing "apply"
      ;; Note: .applyTo is sometimes generated by clojure even without an explicit 'apply'.
      (t/is (= 42 (apply r-a [v])))
      (t/is (= 11 (r-a (apply r-a [v 11])))))))

(t/deftest empty-test
  (sut/def-record Empty1 [])
  (sut/def-record Empty2 [])

  (t/is (not= Empty1 Empty2))

  (t/is (not= (Empty1) (Empty2))))

(t/deftest no-foreign-keys-test
  (t/is (some? (throws #(get (R r-a 42 r-b "foo") :bla))))
  
  (t/is (some? (throws #(assoc (R r-a 42 r-b "foo") :bla 1)))))

(t/deftest no-dissoc-keys-test
  (t/is (some? (throws #(dissoc (R r-a 42 r-b "foo") r-a)))))

(t/deftest printer-test
  (t/testing "Record instances"
    (let [v (R r-a 42 r-b "foo")]
      (t/is (= "#active.data.raw-record-test/R{r-a 42, r-b \"foo\"}" (pr-str v)))
      ;; Note: (str) is sometimes different - but no in maps?
      (t/is (= "{:foo \"bar\"}" (str {:foo "bar"})))
      (t/is (= "#active.data.raw-record-test/R{r-a 42, r-b \"foo\"}" (str v)))

      (t/is (= "#active.data.raw-record-test/R{r-a 42, r-b \"foo\"}\n" (with-out-str (pp/pprint v))))
      ))
  (t/testing "Records themselves"
   ;; TODO: or just the record type name?
   (t/is (= "#active.data.record.Record{r-a, r-b}" (pr-str R))))
  )

(t/deftest extends-test
  (sut/def-record ExtR :extends R [r-c])

  (let [v (ExtR r-a 42 r-b "foo" r-c :bla)]
    
    (t/is (= 10 (r-a (assoc v r-a 10))))
    (t/is (= "yyy" (r-c (assoc v r-c "yyy")))))

  (t/testing "predicates"
    (let [v (ExtR r-a 42 r-b "foo" r-c :bla)]
      (t/is (sut/is-a? ExtR v))
      (t/is (sut/is-a? R v))
      (t/is (sut/is-extended-from? R v))

      (t/is (not (sut/is-exactly-a? R v)))
      (t/is (sut/is-exactly-a? ExtR v)))))

(t/deftest transient-test
  (let [v (R r-a 42 r-b "foo")]

    (t/is (= 11 (r-a (-> (transient v)
                         (assoc! r-a 11)
                         (persistent!)))))

    (let [f (sut/mutator! R r-a)]
      (t/is (= 11 (r-a (-> (transient v)
                           (f 11)
                           (persistent!))))))))

(t/deftest validator-test
  (sut/def-record ValidatedT
    :validator (validator/field-assertions {vt-a int?
                                            vt-b int?})
    [vt-a vt-b])
  
  (let [valid (ValidatedT vt-a 42 vt-b 21)]
    (t/testing "contruction checks for validity"
      (t/is (throws #(ValidatedT vt-a :foo vt-b 21))))

    (t/testing "modification checks for validity"
      (t/is (throws #(assoc valid vt-a :foo)))
      (t/is (throws #(into valid {vt-a :foo})))
      (t/is (throws #(empty valid))))))

(t/deftest destructuring-works-test
  (let [{a r-a b r-b} (R r-a 42 r-b :foo)]
    (t/is (= a 42))
    (t/is (= b :foo))))
